# 進化的アーキテクチャ - 詳細ガイド

## ドキュメント情報

- **作成日**: 2025-11-29
- **対象者**: 開発チーム
- **目的**: アーキテクチャが段階的に進化する戦略と判断基準を明文化

---

## 1. 進化的アーキテクチャとは

### 1.1 定義

**進化的アーキテクチャ (Evolutionary Architecture)** とは、アーキテクチャを事前に完全に設計するのではなく、**段階的に進化**させていく手法。

### 1.2 なぜ進化的アーキテクチャか？

#### 従来のアプローチ (Big Design Up Front)

```
事前に完璧な設計
  ↓
実装
  ↓
問題: 仕様変更に対応できない
      過剰設計になる
      学習機会を失う
```

#### 進化的アプローチ

```
最小限の設計
  ↓
実装・測定
  ↓
学び・フィードバック
  ↓
必要に応じて進化
```

### 1.3 このプロジェクトでの適用理由

1. **仕様が流動的**: 曳光弾型開発により、ユーザーフィードバックを得ながら仕様が進化する
2. **早期価値提供**: 過度な設計に時間をかけず、早くリリースする
3. **学習重視**: 実装を通じて理解を深める
4. **技術的負債管理**: 意図的な妥協を記録し、計画的に返済

---

## 2. アーキテクチャ進化の3つのフェーズ

### Phase 1: シンプルな構成 (MVP)

**目的**: システム全体を貫通する最小パスを実装

**特徴**:

- **実装スタイル**: 手続き型・関数型
- **データ**: ハードコードされたマスターデータ
- **構成**: 単一ファイル、またはシンプルなディレクトリ構造
- **デプロイ**: ローカル実行、または簡易デプロイ

**ディレクトリ構成例**:

```
financial-app/
├── src/
│   ├── taxCalculator.ts      # 税金計算 (純粋関数)
│   ├── simulation.ts          # シミュレーション (手続き型)
│   └── constants.ts           # マスターデータ (ハードコード)
├── tests/
│   └── simulation.test.ts
└── specs/
    └── examples/
        └── uc001.examples.ts
```

**このフェーズで作るもの**:

- UC-001: 老後までにいくら貯まるか
- 税金計算ロジック (基礎控除のみ)
- 社会保険料計算 (簡略化)

**技術的負債**:

- DEBT-001: マスターデータのハードコード
- DEBT-002: 控除項目の省略
- DEBT-003: 標準報酬月額の簡略化

**移行判断基準**:

- ✅ UC-001が完成し、ユーザーフィードバックを得た
- ✅ UC-002の実装が複雑化し始めた
- ✅ ファイル数が10個を超え、構造が必要になった

---

### Phase 2: モジュール化

**目的**: 複雑性が増した機能を整理し、保守性を向上

**特徴**:

- **実装スタイル**: 必要に応じてOOP化 (Strategy パターンなど)
- **データ**: 設定ファイル化 (YAML/JSON)
- **構成**: モジュールごとにディレクトリを分割
- **デプロイ**: Docker化、CI/CD導入

**ディレクトリ構成例**:

```
financial-app/
├── shared/
│   └── domain/
│       ├── taxCalculator.ts
│       ├── socialInsurance.ts
│       ├── investment.ts
│       └── types.ts
├── backend/
│   ├── api/
│   │   └── simulation.ts
│   ├── services/
│   │   └── simulationEngine.ts
│   └── data/
│       ├── tax_policy_2024.yaml
│       └── tax_policy_2025.yaml
├── frontend/
│   └── src/
│       ├── components/
│       └── hooks/
├── tests/
│   ├── domain/
│   └── integration/
└── specs/
```

**このフェーズで作るもの**:

- UC-002: 年次キャッシュフロー推移
- UC-101: 投資リターンを含めた資産推移
- 設定ファイルによるマスターデータ管理
- 複数年度の税制対応

**技術的負債の返済**:

- ✅ DEBT-001: マスターデータを設定ファイル化
- ✅ DEBT-002: 配偶者控除・扶養控除を追加

**移行判断基準**:

- ✅ ユーザー数が1,000人を超えた
- ✅ パフォーマンス問題が測定された
- ✅ チーム規模が5人以上になった

---

### Phase 3: スケールアーキテクチャ

**目的**: 大規模ユーザーとチームに対応

**特徴**:

- **実装スタイル**: マイクロサービス化（必要なら）
- **データ**: データベース化 (PostgreSQL)
- **構成**: サービスごとに独立したリポジトリ
- **デプロイ**: Kubernetes、分散システム

**ディレクトリ構成例**:

```
financial-app/
├── services/
│   ├── api-gateway/
│   ├── simulation-service/
│   ├── tax-service/
│   ├── investment-service/
│   └── user-service/
├── infrastructure/
│   ├── kubernetes/
│   └── terraform/
├── database/
│   └── migrations/
└── monitoring/
```

**このフェーズで作るもの**:

- UC-105: モンテカルロシミュレーション
- UC-201-205: FP専門機能
- マルチテナント対応
- 高度な分析・レポート機能

**技術的負債の返済**:

- ✅ DEBT-001: マスターデータをDB化
- ✅ DEBT-004: モンテカルロシミュレーション

**移行判断基準**:

- ✅ ユーザー数が10,000人を超えた
- ✅ 収益化が確定した
- ✅ チーム規模が10人以上になった
- ✅ サービスごとに独立したスケールが必要

---

## 3. 移行の判断基準

### 3.1 測定駆動の原則

**重要**: 憶測で移行しない。必ず測定してから判断する。

#### 測定すべき指標

| 指標 | Phase 1 → Phase 2 | Phase 2 → Phase 3 |
|------|-------------------|-------------------|
| **ユーザー数** | 100人以上 | 10,000人以上 |
| **レスポンス時間** | 2秒以上 | 1秒以上 |
| **ファイル数** | 10個以上 | 50個以上 |
| **コードの複雑性** | 関数が200行以上 | モジュールの依存が複雑化 |
| **チーム規模** | 3人以上 | 10人以上 |
| **デプロイ頻度** | 週1回以上 | 日1回以上 |

### 3.2 移行のタイミング

#### ❌ 移行すべきでないケース

- パフォーマンス問題が**測定されていない**
- ユーザーからの要望が**ない**
- チームが小規模（1-2人）
- 「将来必要になるかもしれない」という憶測

#### ✅ 移行すべきケース

- パフォーマンス問題が**実測された**
- ユーザーからの要望が**明確**
- チーム規模が拡大
- 保守性が低下し、開発速度が落ちた

---

## 4. 段階的な移行戦略

### 4.1 Strangler Fig パターン

新しいアーキテクチャを**既存システムの周りに**構築し、徐々に置き換える。

```
Phase 1: モノリシック
  ↓ 一部の機能をモジュール化
Phase 2: Modular Monolith
  ↓ 一部のモジュールをサービス化
Phase 3: Microservices
```

**例**:

```
Step 1: 税金計算モジュールを分離
  taxCalculator.ts → services/tax-service/

Step 2: 投資計算モジュールを分離
  investment.ts → services/investment-service/

Step 3: シミュレーションエンジンを分離
  simulation.ts → services/simulation-service/
```

### 4.2 並行実行による検証

新しいアーキテクチャを**並行実行**し、結果を比較して検証する。

```typescript
// 古い実装
const oldResult = oldSimulationEngine(input)

// 新しい実装
const newResult = newSimulationEngine(input)

// 結果を比較
if (oldResult !== newResult) {
  logger.warn('Migration validation failed', { oldResult, newResult })
}

// 本番では古い実装を返す（安全）
return oldResult
```

---

## 5. 各フェーズでの技術選択

### Phase 1: シンプルな構成

| 項目 | 選択 | 理由 |
|------|------|------|
| **言語** | TypeScript | 型安全性、フロント/バック統一 |
| **ランタイム** | Deno/Bun/Node.js | 柔軟に選択 |
| **データ** | ハードコード | 最速実装 |
| **テスト** | Vitest/Jest | 軽量、高速 |
| **フロント** | HTML + HTMX | MVP向け、シンプル |

### Phase 2: モジュール化

| 項目 | 選択 | 理由 |
|------|------|------|
| **アーキテクチャ** | Modular Monolith | 保守性とシンプルさの両立 |
| **データ** | YAML/JSON | 設定ファイル化 |
| **フロント** | React + TypeScript | リッチなUI |
| **デプロイ** | Docker | 環境の統一 |

### Phase 3: スケールアーキテクチャ

| 項目 | 選択 | 理由 |
|------|------|------|
| **アーキテクチャ** | Microservices (必要なら) | スケール、独立デプロイ |
| **データ** | PostgreSQL | トランザクション、JSONB |
| **インフラ** | Kubernetes | スケーラビリティ |
| **計算エンジン** | Go/Rust (測定後) | パフォーマンス最適化 |

---

## 6. リファクタリングの戦略

### 6.1 継続的リファクタリング

**毎スプリント**: 技術的負債を1つ返済

**例**:
- Sprint 1: DEBT-002 (配偶者控除追加)
- Sprint 2: コードの重複を削除
- Sprint 3: DEBT-001 (設定ファイル化)

### 6.2 大規模リファクタリング

**年次**: アーキテクチャレビューを実施

**チェックリスト**:
- [ ] 現在のアーキテクチャは適切か？
- [ ] パフォーマンス問題はあるか？
- [ ] 技術的負債の返済計画は適切か？
- [ ] 次のフェーズへの移行タイミングか？

---

## 7. 進化の記録

### 7.1 アーキテクチャ決定記録 (ADR: Architecture Decision Record)

重要な決定は `docs/adr/` に記録する。

**フォーマット**:

```markdown
# ADR-001: マスターデータのハードコード

## Status
Accepted

## Context
Phase 1では最速実装を優先し、マスターデータをハードコードする。

## Decision
税制データをPython定数として記述する。

## Consequences
- Pros: 実装が速い、テストが容易
- Cons: 年度更新時にコード変更が必要

## Migration Plan
Phase 2で設定ファイル化する (DEBT-001)
```

---

## 8. まとめ

### 進化的アーキテクチャの原則

1. **測定駆動**: 問題を測定してから解決策を導入
2. **段階的**: Phase 1 → Phase 2 → Phase 3
3. **柔軟性**: 学びに応じて方針を調整
4. **透明性**: 決定を記録し、チームで共有

### 現在のフェーズ

**Phase 1**: UC-001の実装中

### 次のマイルストーン

- [ ] UC-001完成
- [ ] ユーザーフィードバック取得
- [ ] Phase 2移行の判断

---

## 参考文献

- **Building Evolutionary Architectures** (Neal Ford, Rebecca Parsons, Patrick Kua)
- **The Pragmatic Programmer** (Andrew Hunt, David Thomas)
- **Working Effectively with Legacy Code** (Michael Feathers)

---

**最終更新**: 2025-11-29
